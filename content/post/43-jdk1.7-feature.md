+++
toc = true
title = "JDK1.7新特性详解"
description = "JDK1.7新特性详解"
tags = [
	"jdk"

]
date = "2017-12-15 18:00:36"
categories = [
    "java"
]
menu = "main"
+++

JDK7对Java语法有少量更新，重点是在易用性和便捷性的改进。

## 1.二进制字面量

JDK7开始，终于可以用二进制来表示整数（byte,short,int和long）。使用二进制字面量的好处是，可以是代码更容易被理解。语法非常简单，只要在二进制数值前面加 0b或者0B

```
byte nByte = (byte)0b0001;  
short nShort = (short)0B0010;  
int nInt = 0b0011;  
long nLong = 0b0100L; 
```

## 2.数字字面量可以出现下划线

对于一些比较大的数字，我们定义起来总是不方面，经常缺少或者增加位数。JDK7为我们提供了一种解决方案，下划线可以出现在数字字面量。

```
int a = 10_0000_0000;  
long b = 0xffff_ffff_ffff_ffffl;  
byte c = 0b0001_1000;  
```

注意：你只能将下划线置于数字之间，以下使用方法是错误的，

1. 数字的开头或者结尾
2. 小数点的前后
3. ‘F’或者‘f’的后缀
4. 只能用数字的位置

```
nt err1 = _11,err2=11_;  
float err3=3._4,err4=3_.4;  
long err5=0x888_f;  
```

## 3.switch 语句可以用字符串了

这个功能千呼万唤，终于出来了

```
private static void switchString(String str){  
        switch(str){  
            case "one":  
                System.err.println("1");  
                break;  
            case "two":  
                System.out.println("2");  
                break;  
            default :  
                System.out.println("err");  
        }  
}  
```

## 4.泛型实例的创建可以通过类型推断来简化

以后你创建一个泛型实例，不需要再详细说明类型，只需用<>,编译器会自动帮你匹配

```
//例如   
Map<String, List<String>> myMap = new HashMap<String, List<String>>();  
//可以简化为  
Map<String, List<String>> myMap = new HashMap<>();  
```

## 5.在可变参数方法中传递非具体化参数（Non-Reifiable Formal Parameters）,改进编译警告和错误

有些参数类型，例如ArrayList<Number> 和 List<String>,是非具体化的（non-reifiable）.在编译阶段，编译器会擦除该类型信息。

Heappollution 指一个变量被指向另外一个不是相同类型的变量。例如

```
List l = new ArrayList<Number>();  
List<String> ls = l;       // unchecked warning  
l.add(0, new Integer(42)); // another unchecked warning  
String s = ls.get(0);      // ClassCastException is thrown  
```

回到我们的主题，在jdk7中，当你定义下面的函数时

```
public static <T> void addToList (List<T> listArg, T... elements) {  
    for (T x : elements) {  
      listArg.add(x);  
    }  
  }  
```

你会得到一个warning

`warning: [varargs] Possible heap pollution from parameterized vararg type `

在jdk7之前，当你调用一个含有非具体化参数的可变参数方法，你必须自行保证不会发生`heappollution`。这有一个问题，如果调用者对方法不熟悉，他根本无法判断。JDK7对此做了改进，在该方法被定义时久发出警告

要消除警告，可以有三种方式

1. 加 annotation @SafeVarargs
2. 加 annotation @SuppressWarnings({"unchecked", "varargs"})
3. 使用编译器参数 –Xlint:varargs;

## 6.try-with-resources 语句

jdk7提供了try-with-resources,可以自动关闭相关的资源（只要该资源实现了AutoCloseable接口，jdk7为绝大部分资源对象都实现了这个接口）

```
static String readFirstLineFromFile(String path) throws IOException {  
  try (BufferedReader br = new BufferedReader(new FileReader(path))) {  
    return br.readLine();  
  }  
}  
```

try 语句块中还可以同时处理多个资源,可以跟普通的try语句一样catch异常，有finally语句块

```
try (  
      java.util.zip.ZipFile zf = new java.util.zip.ZipFile(zipFileName);  
      java.io.BufferedWriter writer = java.nio.file.Files.newBufferedWriter(outputFilePath, charset)  
    ) {  
}catch(…){  
}finally{  
}  
```

## 7.Catch多个Exception，rethrow exception 改进了类型检测

很多时候，我们捕获了多个异常，却做了相同的事情，比如记日志，包装成新的异常，然后rethrow。这时，代码就不那么优雅了，例如

```
catch (IOException ex) {  
     logger.log(ex);  
     throw ex;  
catch (SQLException ex) {  
     logger.log(ex);  
     throw ex;  
}  
```

Jdk7允许捕获多个异常

```
catch (IOException|SQLException ex) {  
    logger.log(ex);  
    throw ex;  
}  
```

注意，catch后面的异常参数是final的，不能重新再复制

`RethrowException`更具包容性的类型检测

当你重新抛出多个异常时，不再需要详细定义异常类型了，编译器已经知道你具体抛出的是哪个异常了。你只需在方法定义的时候声明需要抛出的异常即可

```
public void call() throws ReflectiveOperationException, IOException {  
    try {  
      callWithReflection(arg);  
    } catch (final Exception e) {  
      logger.trace("Exception in reflection", e);  
      throw e;  
    }  
}  
```

参考资料

Jdk7官网 [http://openjdk.java.net/projects/jdk7/](http://openjdk.java.net/projects/jdk7/)